# There are two ways of creating threads 
# -using Thread class present in threading module
# 1.import thread class from threading module 
# 2.Create a function containing code to be executed parally
# 3. create a object of that THread class
# 4.Start created thread using start() method



# -using Thread class present in threading module
# 1.import thread class from threading module 
from threading import Thread,current_thread
# # 2.Create a function containing code to be executed parally
# def display(n,msg):
#     for i in range(n):
#         print(msg)
# # 3. create a object of that THread class
# t1=Thread(target=display,args=(4,"hello"))
# # 4.Start created thread using start() method
# t1.start()
# print(t1)


# def display(n,msg):
#     for i in range(n):
#         print(msg)
# t1=Thread(target=display,kwargs={'n':5,'msg':'hello pc'})
# t1.start()
# print(t1)


# def display(n):
#     #excured by tq thread
#     print("t1 thread details",current_thread())
#     for i in range(n):
#         print("Hello pc")
# t1=Thread(target=display,args=(5,))

# t1.start()

# # Executed by main thread
# for i in range(3):
#     print("Executed by main thread")


#if your code in a method in a class
#so how to create threads for methods

# class Example:
#     def display(self,n):
#         for i in range(n):
#             print("Home")


# e1=Example()
# t1=Thread(target=e1.display,args=(5,))
# t1.start()
# #executed by main thread
# for i in range(5):
#     print("Welcome")


# class Example:
#     @classmethod
#     def display(self,n):
#         for i in range(n):
#             print("Home")


# e1=Example()
# t1=Thread(target=Example.display,args=(5,))
# t1.start()
# #executed by main thread
# for i in range(5):
#     print("Welcome")



# class Example:
#     @staticmethod
#     #for the static method we need to remoce self and pass only the arguments
#     def display(n):
#         for i in range(n):
#             print("Home")


# e1=Example()
# t1=Thread(target=Example.display,args=(5,))
# t1.start()
# #executed by main thread
# for i in range(5):
#     print("Welcome")



# - by extending a the Thread class. Means you have to make a child class by inheriting the Thread class

from time import sleep
from threading import Thread
videos = ['oops syllabus', 'constructor','destructor','file handling']

#we are here inheriting the Thread method after inheriting that we will cretae the run method also. Here we are doing overwriting cause there is also a runmethod in the Thread which is inherited by Myclass

# class Myclass(Thread):
#     def run(self):
#         for vid in videos:
#             print(f"{vid} starting uploading")
#             sleep(3)
#             print(f"{vid} uploaded.")
        

# #here if we are creating an object of myclass that will be called a thread
# t1=Myclass()
# #to execute that thread
# t1.start()


# for i in range(4):
#     sleep(0.5)
#     print("Checking copyrights")


# in this class you also can use constructer but you need to handle an error. You have to inherite(overiding) the constuctor from the Thread class then you can do use consrtuctor. Cause it is important to use consructor of the Thread class cause there is some important variables in the Thread consructor that heplps to run the thread. So if we do not inher
# class Myclass(Thread):
#     def __init__(self,val=True):
#         print("constructor called")
#         # we also can add restrictsions like the video is suitable for kid only
#         self.kid=val
#         Thread.__init__(self)
#     def Compression(self):
#         print("Video compression code here")
#     def run(self):
#         self.Compression()
#         if self.kid is True:
#             print("suitable for kids")
#         for vid in videos:
#             print(f"{vid} starting uploading")
#             sleep(1)
#             print(f"{vid} uploaded.")
        

# #here if we are creating an object of myclass that will be called a thread
# t1=Myclass(False)
# #to execute that thread
# t1.start()


# for i in range(4):
#     sleep(0.5)
#     print("Checking copyrights")

# Biggest advantage of using thread in this method -> You can access data generated by threads here.


class Myclass(Thread):
    def __init__(self,val=True):
        Thread.__init__(self)
        self.kid=val
        print("Consructor is created")
    def compressor(self):
        print("ok")
    def run(self):
        a=10
        b=20
        self.compressor()
        if self.kid is True:
            print("Video is for kids")
        for i in videos:
            print(f"{i} video is uploading")
            sleep(1)
            print("Checking")
        self.res=a+b

t1=Myclass()
t1.start()
sleep(10)
print("result is",t1.res)

for i in range(4):
    sleep(0.5)
    print("Checking your video")
        











